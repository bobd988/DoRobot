# Leader-Follower X5 æ•°æ®ä¿å­˜é—®é¢˜ä¿®å¤æ€»ç»“

> æ–‡æ¡£åˆ›å»ºæ—¶é—´ï¼š2026-02-04
> ç³»ç»Ÿï¼šLeader-Follower X5 (Feetech â†’ ARX-X5)
> é—®é¢˜ç±»å‹ï¼šæ•°æ®å½•åˆ¶ä¿å­˜å¤±è´¥

---

## ğŸ“‹ ç›®å½•

1. [é—®é¢˜æ¦‚è§ˆ](#é—®é¢˜æ¦‚è§ˆ)
2. [é—®é¢˜è¯¦æƒ…ä¸è§£å†³æ–¹æ¡ˆ](#é—®é¢˜è¯¦æƒ…ä¸è§£å†³æ–¹æ¡ˆ)
3. [ä¿®æ”¹çš„æ–‡ä»¶](#ä¿®æ”¹çš„æ–‡ä»¶)
4. [è°ƒè¯•æŠ€å·§](#è°ƒè¯•æŠ€å·§)
5. [æµ‹è¯•éªŒè¯](#æµ‹è¯•éªŒè¯)
6. [é™„å½•](#é™„å½•)

---

## é—®é¢˜æ¦‚è§ˆ

åœ¨ä½¿ç”¨ Leader-Follower X5 æœºæ¢°è‡‚è¿›è¡Œæ•°æ®å½•åˆ¶æ—¶ï¼Œé‡åˆ°äº†ä¸€ç³»åˆ—æ•°æ®ä¿å­˜å¤±è´¥çš„é—®é¢˜ã€‚ä¸»è¦è¡¨ç°ä¸ºï¼š
- æ—¶é—´æˆ³åŒæ­¥éªŒè¯å¤±è´¥
- é‡è¯•æœºåˆ¶å¤±æ•ˆ
- æ•°æ®ç±»å‹åˆ¤æ–­é”™è¯¯
- å†…éƒ¨æ ‡è®°é”®å†²çª

ç»è¿‡å¤šè½®è°ƒè¯•å’Œä¿®å¤ï¼Œæœ€ç»ˆè§£å†³äº†æ‰€æœ‰é—®é¢˜ï¼Œæ•°æ®å¯ä»¥æ­£å¸¸ä¿å­˜ã€‚

---

## é—®é¢˜è¯¦æƒ…ä¸è§£å†³æ–¹æ¡ˆ

### é—®é¢˜ 1ï¼šæ—¶é—´æˆ³åŒæ­¥éªŒè¯å¤±è´¥ â±ï¸

#### é”™è¯¯ä¿¡æ¯
```
ValueError: One or several timestamps unexpectedly violate the tolerance inside episode range.
[{'diff': np.float64(0.535667896270752), ...},
 {'diff': np.float64(0.5431115627288818), ...}]
```

#### é—®é¢˜æè¿°
- æ—¶é—´æˆ³å·®å¼‚èŒƒå›´ï¼š0.535s ~ 0.79s
- åˆå§‹å®¹å·®è®¾ç½®ï¼š0.5s
- æœŸæœ›é—´éš”ï¼š0.0333s (30fps)

#### æ ¹æœ¬åŸå› 
1. VRé¥æ“ä½œç³»ç»Ÿå­˜åœ¨å›ºæœ‰å»¶è¿Ÿ
2. æ•°æ®é‡‡é›†æ—¶ä¸åŒä¼ æ„Ÿå™¨ï¼ˆç›¸æœºã€æœºæ¢°è‡‚ï¼‰çš„æ—¶é—´æˆ³ä¸å®Œå…¨åŒæ­¥
3. ç³»ç»Ÿè´Ÿè½½å¯¼è‡´çš„å¸§ä¸¢å¤±æˆ–å»¶è¿Ÿ

#### è§£å†³æ–¹æ¡ˆ
```python
# æ–‡ä»¶ï¼šoperating_platform/core/record.py:196
tolerance_s=1.0,  # ä» 0.5s â†’ 0.6s â†’ 1.0s
```

**ä¿®æ”¹å†å²**ï¼š
- åˆå§‹å€¼ï¼š0.5sï¼ˆå¤ªä¸¥æ ¼ï¼‰
- ç¬¬ä¸€æ¬¡è°ƒæ•´ï¼š0.6sï¼ˆä»ä¸å¤Ÿï¼‰
- æœ€ç»ˆå€¼ï¼š1.0sï¼ˆé€‚åº”VRé¥æ“ä½œçš„å»¶è¿Ÿç‰¹æ€§ï¼‰

---

### é—®é¢˜ 2ï¼šé‡è¯•æœºåˆ¶å¤±æ•ˆ - "size key not found" ğŸ”„

#### é”™è¯¯ä¿¡æ¯
```
ValueError: size key not found in episode_buffer
```

#### é—®é¢˜æè¿°
- ç¬¬ä¸€æ¬¡ä¿å­˜å°è¯•å¤±è´¥åï¼Œé‡è¯•æ—¶æŠ¥é”™
- "size" å’Œ "task" é”®ä¸¢å¤±

#### æ ¹æœ¬åŸå› 
```python
# åŸå§‹ä»£ç ä½¿ç”¨ pop() åˆ é™¤é”®
episode_length = episode_buffer.pop("size")
tasks = episode_buffer.pop("task")
```
- `pop()` æ–¹æ³•ä¼šä»å­—å…¸ä¸­åˆ é™¤é”®
- ç¬¬ä¸€æ¬¡å°è¯•å¤±è´¥åï¼Œé‡è¯•æ—¶è¿™äº›é”®å·²ç»ä¸å­˜åœ¨
- éªŒè¯å‡½æ•° `validate_episode_buffer` éœ€è¦è¿™äº›é”®

#### è§£å†³æ–¹æ¡ˆæ¼”è¿›

**å°è¯• 1ï¼ˆå¤±è´¥ï¼‰**ï¼š
```python
# æ”¹ç”¨ get() ä¿ç•™é”®
episode_length = episode_buffer.get("size")
tasks = episode_buffer.get("task")
```
é—®é¢˜ï¼šé”®æ²¡æœ‰è¢«åˆ é™¤ï¼Œåç»­å¤„ç†ä¼šå‡ºé”™

**å°è¯• 2ï¼ˆå¤±è´¥ï¼‰**ï¼š
```python
# åœ¨éªŒè¯ååˆ é™¤
validate_episode_buffer(...)
episode_length = episode_buffer.pop("size")
tasks = episode_buffer.pop("task")
```
é—®é¢˜ï¼šæ—¶é—´æˆ³éªŒè¯åœ¨åé¢ï¼Œå¦‚æœå¤±è´¥ï¼Œé”®å·²è¢«åˆ é™¤

**æœ€ç»ˆæ–¹æ¡ˆï¼ˆæˆåŠŸï¼‰**ï¼š
```python
# ç«‹å³åˆ é™¤ï¼Œä½†åœ¨é‡è¯•æ—¶ä»å…¶ä»–æ•°æ®æ¨æ–­
episode_length = episode_buffer.pop("size") if "size" in episode_buffer else None
tasks = episode_buffer.pop("task") if "task" in episode_buffer else None

if episode_length is None:
    # é‡è¯•æ—¶ä» timestamp æ¨æ–­
    if "timestamp" in episode_buffer:
        ts = episode_buffer["timestamp"]
        if isinstance(ts, (np.ndarray, list)):
            episode_length = len(ts)
            logging.info(f"Retry detected, inferred episode_length={episode_length}")
```

---

### é—®é¢˜ 3ï¼šæ•°ç»„ç±»å‹åˆ¤æ–­é”™è¯¯ - "array ambiguous" ğŸ“Š

#### é”™è¯¯ä¿¡æ¯
```
ValueError: The truth value of an array with more than one element is ambiguous.
Use a.any() or a.all()
```

#### é—®é¢˜æè¿°
- åœ¨ `validate_episode_buffer` ä¸­ä½¿ç”¨ `if episode_index < 0` åˆ¤æ–­
- ä½† `episode_index` åœ¨ç¬¬ä¸€æ¬¡å°è¯•æ—¶è¢«è½¬æ¢ä¸ºæ•°ç»„
- é‡è¯•æ—¶éªŒè¯å¤±è´¥

#### æ ¹æœ¬åŸå› 
```python
# åœ¨ save_episode ä¸­ï¼Œepisode_index è¢«è½¬æ¢ä¸ºæ•°ç»„
episode_buffer["episode_index"] = np.full((episode_length,), episode_index)
```
- ç¬¬ä¸€æ¬¡å°è¯•ï¼šepisode_index æ˜¯æ ‡é‡ï¼ˆintï¼‰
- é‡è¯•æ—¶ï¼šepisode_index å·²ç»æ˜¯æ•°ç»„ï¼ˆndarrayï¼‰
- Python æ— æ³•ç›´æ¥æ¯”è¾ƒæ•°ç»„å’Œæ ‡é‡

#### è§£å†³æ–¹æ¡ˆ
```python
# æ–‡ä»¶ï¼šoperating_platform/utils/dataset.py:843
episode_index = episode_buffer["episode_index"]

# å¤„ç†æ•°ç»„å’Œæ ‡é‡ä¸¤ç§æƒ…å†µ
if isinstance(episode_index, np.ndarray):
    if len(episode_index) > 0:
        episode_index_scalar = episode_index[0]
        # éªŒè¯æ•°ç»„ä¸­æ‰€æœ‰å€¼æ˜¯å¦ä¸€è‡´
        if not np.all(episode_index == episode_index_scalar):
            raise ValueError(f"episode_index array has inconsistent values")
        episode_index = episode_index_scalar
    else:
        raise ValueError("episode_index array is empty")

# ç°åœ¨å¯ä»¥å®‰å…¨åœ°æ¯”è¾ƒ
if episode_index < 0:
    raise ValueError(f"episode_index must be non-negative, got {episode_index}")
```

---

### é—®é¢˜ 4ï¼š"index" é”®å†²çª ğŸ”‘

#### é”™è¯¯ä¿¡æ¯
```
TypeError: 'int' object is not iterable
```

#### é—®é¢˜æè¿°
- ç¬¬ä¸€æ¬¡å°è¯•æ—¶å°±æ£€æµ‹åˆ°"retry"
- å¯¼è‡´è·³è¿‡äº†å¿…è¦çš„æ•°æ®è½¬æ¢
- æŸäº›å­—æ®µä»ç„¶æ˜¯æ ‡é‡è€Œä¸æ˜¯æ•°ç»„

#### æ ¹æœ¬åŸå› 

**1. episode_buffer åˆå§‹åŒ–æ—¶å°±åŒ…å« "index" é”®**ï¼š
```python
# æ–‡ä»¶ï¼šoperating_platform/dataset/dorobot_dataset.py:873
def create_episode_buffer(self, episode_index: int | None = None) -> dict:
    ep_buffer = {}
    ep_buffer["size"] = 0
    ep_buffer["task"] = []
    for key in self.features:
        # æ‰€æœ‰ features ä¸­çš„é”®éƒ½è¢«åˆå§‹åŒ–ä¸ºç©ºåˆ—è¡¨
        ep_buffer[key] = current_ep_idx if key == "episode_index" else []
    return ep_buffer
```

**2. "index" åœ¨ DEFAULT_FEATURES ä¸­å®šä¹‰**ï¼š
```python
# æ–‡ä»¶ï¼šoperating_platform/utils/dataset.py:57
DEFAULT_FEATURES = {
    "timestamp": {"dtype": "float32", "shape": (1,), "names": None},
    "frame_index": {"dtype": "int64", "shape": (1,), "names": None},
    "episode_index": {"dtype": "int64", "shape": (1,), "names": None},
    "index": {"dtype": "int64", "shape": (1,), "names": None},  # â† è¿™é‡Œ
    "task_index": {"dtype": "int64", "shape": (1,), "names": None},
}
```

**3. é”™è¯¯çš„é‡è¯•æ£€æµ‹é€»è¾‘**ï¼š
```python
# åŸå§‹ä»£ç ï¼ˆé”™è¯¯ï¼‰
already_processed = "index" in episode_buffer  # æ€»æ˜¯ Trueï¼
```

#### è°ƒè¯•æ—¥å¿—
```
[save_episode] Entry - buffer keys: ['size', 'task', ..., 'index']...
[save_episode] Has 'size': True, Has 'task': True, Has 'index': True
[save_episode] 'index' key already exists! type: <class 'list'>, shape: N/A, first few values: []
[save_episode] Detected retry for episode 0, skipping buffer transformations  # â† é”™è¯¯ï¼
```

#### è§£å†³æ–¹æ¡ˆ
```python
# æ–‡ä»¶ï¼šoperating_platform/dataset/dorobot_dataset.py:1078
# æ£€æŸ¥ "index" æ˜¯å¦ä¸º ndarrayï¼Œè€Œä¸ä»…ä»…æ£€æŸ¥æ˜¯å¦å­˜åœ¨
already_processed = "index" in episode_buffer and isinstance(episode_buffer.get("index"), np.ndarray)

if already_processed:
    logging.info(f"Buffer already processed (index is ndarray), skipping transformations")
else:
    if "index" in episode_buffer:
        logging.warning(f"'index' exists but is not ndarray (type: {type(episode_buffer['index'])}), will overwrite")
    logging.debug(f"First attempt for episode {episode_index}, applying buffer transformations")
```

**å…³é”®æ”¹è¿›**ï¼š
- ä¸ä»…æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨
- è¿˜æ£€æŸ¥å€¼çš„ç±»å‹æ˜¯å¦ä¸º ndarray
- ç©ºåˆ—è¡¨ `[]` â†’ æœªå¤„ç†
- ndarray â†’ å·²å¤„ç†

---

### é—®é¢˜ 5ï¼šå†…éƒ¨æ ‡è®°é”®å¯¼è‡´ç»Ÿè®¡è®¡ç®—å¤±è´¥ ğŸ·ï¸

#### é”™è¯¯ä¿¡æ¯
```
KeyError: '_save_attempt_done'
```

#### é—®é¢˜æè¿°
- æ·»åŠ äº† `_save_attempt_done` æ ‡è®°æ¥æ£€æµ‹é‡è¯•
- ä½† `compute_episode_stats` éå†æ‰€æœ‰é”®å¹¶åœ¨ features ä¸­æŸ¥æ‰¾
- `_save_attempt_done` ä¸åœ¨ features ä¸­ï¼Œå¯¼è‡´ KeyError

#### æ ¹æœ¬åŸå› 
```python
# æ·»åŠ æ ‡è®°ç”¨äºé‡è¯•æ£€æµ‹
episode_buffer["_save_attempt_done"] = True

# åç»­è°ƒç”¨ç»Ÿè®¡å‡½æ•°
ep_stats = compute_episode_stats(episode_buffer, self.features)

# compute_episode_stats å†…éƒ¨
for key in episode_buffer:
    if features[key]["dtype"] == "string":  # â† KeyError: '_save_attempt_done'
        ...
```

#### è§£å†³æ–¹æ¡ˆ
```python
# æ–‡ä»¶ï¼šoperating_platform/dataset/dorobot_dataset.py:1141
# åœ¨è°ƒç”¨ compute_episode_stats ä¹‹å‰åˆ é™¤å†…éƒ¨æ ‡è®°
if "_save_attempt_done" in episode_buffer:
    del episode_buffer["_save_attempt_done"]

ep_stats = compute_episode_stats(episode_buffer, self.features)
```

**è®¾è®¡åŸåˆ™**ï¼š
- å†…éƒ¨æ ‡è®°é”®åº”è¯¥åœ¨ä½¿ç”¨åç«‹å³æ¸…ç†
- ä¸è¦è®©å†…éƒ¨å®ç°ç»†èŠ‚æ³„éœ²åˆ°å¤–éƒ¨æ¥å£

---

### é—®é¢˜ 6ï¼šé‡è¯•æ—¶æ•°æ®è¢«é‡å¤ä¿®æ”¹ ğŸ”

#### é—®é¢˜æè¿°
- ç¬¬ä¸€æ¬¡å°è¯•æ—¶ï¼Œepisode_buffer è¢«ä¿®æ”¹ï¼ˆpopã€è½¬æ¢ä¸ºæ•°ç»„ç­‰ï¼‰
- é‡è¯•æ—¶ä½¿ç”¨åŒä¸€ä¸ª task å¯¹è±¡ï¼ŒåŒ…å«å·²ä¿®æ”¹çš„ buffer
- å¯¼è‡´é‡å¤å¤„ç†æˆ–æ•°æ®ä¸¢å¤±

#### æ ¹æœ¬åŸå› 
```python
# æ–‡ä»¶ï¼šoperating_platform/core/async_episode_saver.py:381
# é‡è¯•æ—¶é‡æ–°ä½¿ç”¨åŒä¸€ä¸ª task å¯¹è±¡
self.save_queue.put(task)  # task.episode_buffer å·²è¢«ä¿®æ”¹
```

#### è§£å†³æ–¹æ¡ˆ
ä½¿ç”¨ `_save_attempt_done` æ ‡è®°å’Œ `already_processed` æ£€æŸ¥ï¼š

```python
# æ£€æµ‹æ˜¯å¦æ˜¯é‡è¯•
is_retry = "_save_attempt_done" in episode_buffer

# æ£€æµ‹æ•°æ®æ˜¯å¦å·²å¤„ç†
already_processed = "index" in episode_buffer and isinstance(episode_buffer.get("index"), np.ndarray)

# åªåœ¨ç¬¬ä¸€æ¬¡å°è¯•æ—¶è¿›è¡Œè½¬æ¢
if not already_processed:
    episode_buffer["index"] = np.arange(self.meta.total_frames, self.meta.total_frames + episode_length)
    episode_buffer["episode_index"] = np.full((episode_length,), episode_index)

    # å †å æ•°ç»„
    for key, ft in self.features.items():
        if key not in ["index", "episode_index", "task_index"] and ft["dtype"] not in ["image", "video", "audio"]:
            episode_buffer[key] = np.stack(episode_buffer[key])
```

**å…³é”®ç‚¹**ï¼š
- ä½¿ç”¨æ ‡è®°è€Œä¸æ˜¯æ¨æ–­çŠ¶æ€
- è·³è¿‡å·²å¤„ç†çš„æ•°æ®è½¬æ¢
- ä¿æŒå¹‚ç­‰æ€§ï¼ˆå¤šæ¬¡æ‰§è¡Œç»“æœç›¸åŒï¼‰

---

### é—®é¢˜ 7ï¼šç›¸æœºè®¾å¤‡è¢«å ç”¨ ğŸ“·

#### é”™è¯¯ä¿¡æ¯
```
RuntimeError: xioctl(VIDIOC_S_FMT) failed, errno=16 Last Error: Device or resource busy
```

#### é—®é¢˜æè¿°
- å¯åŠ¨æ•°æ®å½•åˆ¶æ—¶ï¼Œç›¸æœºè®¾å¤‡æ— æ³•æ‰“å¼€
- é”™è¯¯ç  16 (EBUSY) è¡¨ç¤ºè®¾å¤‡æ­£åœ¨è¢«ä½¿ç”¨

#### æ ¹æœ¬åŸå› 
- ä¹‹å‰çš„è¿›ç¨‹å´©æºƒæˆ–æœªæ­£ç¡®é€€å‡º
- ç›¸æœºè®¾å¤‡æ²¡æœ‰è¢«é‡Šæ”¾

#### è§£å†³æ–¹æ¡ˆ
```bash
# 1. æŸ¥æ‰¾å ç”¨ç›¸æœºçš„è¿›ç¨‹
lsof /dev/video* 2>/dev/null

# è¾“å‡ºç¤ºä¾‹ï¼š
# COMMAND    PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
# python3 326807 dora    5u   CHR  81,14      0t0 1548 /dev/video14

# 2. ç»ˆæ­¢å ç”¨è¿›ç¨‹
kill -9 326807

# 3. éªŒè¯è®¾å¤‡å·²é‡Šæ”¾
lsof /dev/video* 2>/dev/null  # åº”è¯¥æ²¡æœ‰è¾“å‡º
```

**é¢„é˜²æªæ–½**ï¼š
- ä½¿ç”¨ Ctrl+C æ­£å¸¸é€€å‡ºç¨‹åº
- ç¡®ä¿æ¸…ç†è„šæœ¬æ­£ç¡®æ‰§è¡Œ
- æ·»åŠ ä¿¡å·å¤„ç†å™¨é‡Šæ”¾èµ„æº

---

## ä¿®æ”¹çš„æ–‡ä»¶

### 1. `operating_platform/dataset/dorobot_dataset.py`

**ä¿®æ”¹ä½ç½®**ï¼š
- Line 1007-1027: æ·»åŠ é‡è¯•æ£€æµ‹å’Œè°ƒè¯•æ—¥å¿—
- Line 1029-1053: æ”¹è¿› episode_length æ¨æ–­é€»è¾‘
- Line 1070-1088: æ”¹è¿› already_processed æ£€æŸ¥
- Line 1141-1145: åˆ é™¤å†…éƒ¨æ ‡è®°é”®

**å…³é”®ä»£ç ç‰‡æ®µ**ï¼š
```python
# 1. æ·»åŠ è¯¦ç»†è°ƒè¯•æ—¥å¿—
logging.info(f"[save_episode] Entry - buffer keys: {list(episode_buffer.keys())[:10]}...")
logging.info(f"[save_episode] Has 'size': {'size' in episode_buffer}, Has 'task': {'task' in episode_buffer}, Has 'index': {'index' in episode_buffer}")
if "index" in episode_buffer:
    idx_val = episode_buffer["index"]
    logging.warning(f"[save_episode] 'index' key already exists! type: {type(idx_val)}, shape: {idx_val.shape if isinstance(idx_val, np.ndarray) else 'N/A'}")

# 2. æ£€æµ‹é‡è¯•
is_retry = "_save_attempt_done" in episode_buffer
logging.info(f"[save_episode] is_retry={is_retry}")

# 3. ç«‹å³åˆ é™¤ size å’Œ task
episode_length = episode_buffer.pop("size") if "size" in episode_buffer else None
tasks = episode_buffer.pop("task") if "task" in episode_buffer else None

# 4. é‡è¯•æ—¶æ¨æ–­ episode_length
if episode_length is None:
    if "timestamp" in episode_buffer:
        ts = episode_buffer["timestamp"]
        if isinstance(ts, (np.ndarray, list)):
            episode_length = len(ts)
            logging.info(f"Retry detected, inferred episode_length={episode_length}")

# 5. æ”¹è¿› already_processed æ£€æŸ¥
already_processed = "index" in episode_buffer and isinstance(episode_buffer.get("index"), np.ndarray)

# 6. æ·»åŠ æ ‡è®°
if not is_retry:
    episode_buffer["_save_attempt_done"] = True

# 7. åˆ é™¤æ ‡è®°
if "_save_attempt_done" in episode_buffer:
    del episode_buffer["_save_attempt_done"]
```

---

### 2. `operating_platform/utils/dataset.py`

**ä¿®æ”¹ä½ç½®**ï¼š
- Line 843-860: æ”¹è¿› validate_episode_buffer å¤„ç†æ•°ç»„å½¢å¼çš„ episode_index

**å…³é”®ä»£ç ç‰‡æ®µ**ï¼š
```python
def validate_episode_buffer(episode_buffer: dict, total_episodes: int, features: dict):
    if "size" not in episode_buffer:
        raise ValueError("size key not found in episode_buffer")

    if "task" not in episode_buffer:
        raise ValueError("task key not found in episode_buffer")

    episode_index = episode_buffer["episode_index"]

    # å¤„ç†æ•°ç»„å’Œæ ‡é‡ä¸¤ç§æƒ…å†µ
    if isinstance(episode_index, np.ndarray):
        if len(episode_index) > 0:
            episode_index_scalar = episode_index[0]
            if not np.all(episode_index == episode_index_scalar):
                raise ValueError(f"episode_index array has inconsistent values")
            episode_index = episode_index_scalar
        else:
            raise ValueError("episode_index array is empty")

    if episode_index < 0:
        raise ValueError(f"episode_index must be non-negative, got {episode_index}")
```

---

### 3. `operating_platform/core/record.py`

**ä¿®æ”¹ä½ç½®**ï¼š
- Line 196: å¢åŠ æ—¶é—´æˆ³å®¹å·®

**å…³é”®ä»£ç ç‰‡æ®µ**ï¼š
```python
DoRobotDataset(
    # ... å…¶ä»–å‚æ•°
    tolerance_s=1.0,  # ä» 0.5s å¢åŠ åˆ° 1.0sï¼Œé€‚åº”VRé¥æ“ä½œçš„å»¶è¿Ÿ
    # ... å…¶ä»–å‚æ•°
)
```

---

## è°ƒè¯•æŠ€å·§

### 1. æ·»åŠ è¯¦ç»†æ—¥å¿— ğŸ“

**åŸåˆ™**ï¼š
- è®°å½•å…³é”®çŠ¶æ€è½¬æ¢
- è®°å½•æ•°æ®ç±»å‹å’Œå½¢çŠ¶
- è®°å½•æ¡ä»¶åˆ¤æ–­ç»“æœ

**ç¤ºä¾‹**ï¼š
```python
logging.info(f"[save_episode] Entry - buffer keys: {list(episode_buffer.keys())[:10]}...")
logging.info(f"[save_episode] Has 'size': {'size' in episode_buffer}")
logging.info(f"[save_episode] is_retry={is_retry}")
if isinstance(value, np.ndarray):
    logging.info(f"Value is ndarray, shape: {value.shape}")
```

### 2. æ£€æŸ¥æ•°æ®ç±»å‹ ğŸ”

**å¸¸è§é™·é˜±**ï¼š
- æ ‡é‡ vs åˆ—è¡¨ vs ndarray
- ç©ºåˆ—è¡¨ vs None
- int vs np.int64

**æ£€æŸ¥æ–¹æ³•**ï¼š
```python
# ç±»å‹æ£€æŸ¥
if isinstance(value, np.ndarray):
    print(f"ndarray, shape: {value.shape}, dtype: {value.dtype}")
elif isinstance(value, list):
    print(f"list, length: {len(value)}")
elif isinstance(value, (int, float)):
    print(f"scalar: {type(value)}")

# å€¼æ£€æŸ¥
if value is None:
    print("Value is None")
elif isinstance(value, (list, np.ndarray)) and len(value) == 0:
    print("Empty container")
```

### 3. è¿½è¸ªæ•°æ®æµ ğŸ”„

**æ–¹æ³•**ï¼š
1. åœ¨æ¯ä¸ªå¤„ç†é˜¶æ®µæ·»åŠ æ—¥å¿—
2. è®°å½•æ•°æ®çš„è½¬æ¢è¿‡ç¨‹
3. éªŒè¯è¾“å…¥è¾“å‡ºçš„ä¸€è‡´æ€§

**ç¤ºä¾‹**ï¼š
```python
# é˜¶æ®µ1ï¼šæ¥æ”¶æ•°æ®
logging.info(f"[Stage 1] Received buffer with keys: {list(buffer.keys())}")

# é˜¶æ®µ2ï¼šéªŒè¯æ•°æ®
logging.info(f"[Stage 2] Validating buffer...")

# é˜¶æ®µ3ï¼šè½¬æ¢æ•°æ®
logging.info(f"[Stage 3] Transforming buffer...")
logging.info(f"[Stage 3] Before: type={type(buffer['index'])}")
buffer['index'] = np.arange(...)
logging.info(f"[Stage 3] After: type={type(buffer['index'])}, shape={buffer['index'].shape}")
```

### 4. ä½¿ç”¨æ ‡è®°è€Œä¸æ˜¯æ¨æ–­ ğŸ·ï¸

**é”™è¯¯åšæ³•**ï¼š
```python
# é€šè¿‡æ•°æ®ç‰¹å¾æ¨æ–­çŠ¶æ€
if "index" in buffer:  # ä¸å¯é ï¼
    is_processed = True
```

**æ­£ç¡®åšæ³•**ï¼š
```python
# ä½¿ç”¨æ˜¾å¼æ ‡è®°
if "_processing_done" in buffer:
    is_processed = True
```

### 5. è€ƒè™‘é‡è¯•åœºæ™¯ ğŸ”

**è®¾è®¡åŸåˆ™**ï¼š
- ç¡®ä¿æ“ä½œæ˜¯å¹‚ç­‰çš„ï¼ˆå¤šæ¬¡æ‰§è¡Œç»“æœç›¸åŒï¼‰
- ä¿å­˜åŸå§‹æ•°æ®ï¼Œé¿å…ç ´åæ€§ä¿®æ”¹
- ä½¿ç”¨æ ‡è®°è·Ÿè¸ªå¤„ç†çŠ¶æ€

**ç¤ºä¾‹**ï¼š
```python
# æ£€æŸ¥æ˜¯å¦å·²å¤„ç†
if not already_processed:
    # åªåœ¨ç¬¬ä¸€æ¬¡æ‰§è¡Œè½¬æ¢
    buffer["data"] = transform(buffer["data"])
    buffer["_processed"] = True
```

---

## æµ‹è¯•éªŒè¯

### è¿è¡Œæµ‹è¯•

```bash
# å¯åŠ¨æ•°æ®å½•åˆ¶
bash scripts/run_so101.sh 2>&1 | tee /tmp/test-log.txt
```

### éªŒè¯æˆåŠŸçš„æ ‡å¿—

**1. æ—¥å¿—ä¸­åº”è¯¥çœ‹åˆ°**ï¼š
```
âœ“ Queued episode 0 (queue_pos=0, frames=XX, elapsed=XX.Xms)
Creating parquet from Arrow format: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 1/1 [00:00<00:00, XXX.XXba/s]
[VideoEncoder] Encoding video: episode_000000.mp4 (encoder=libx264)
âœ“ Episode 0 saved successfully
Save stats: queued=1 completed=1 failed=0
```

**2. ä¸åº”è¯¥çœ‹åˆ°**ï¼š
```
âœ— Episode 0 failed after 3 retries
ValueError: ...
KeyError: ...
TypeError: ...
```

**3. æ£€æŸ¥ç”Ÿæˆçš„æ–‡ä»¶**ï¼š
```bash
# æ£€æŸ¥æ•°æ®é›†ç›®å½•
ls -lh /home/dora/DoRobot-vr/dataset/leader-follower-x5/

# åº”è¯¥åŒ…å«ï¼š
# - data/
# - meta/
# - videos/
# - episode_000000.parquet
```

### å¸¸è§é—®é¢˜æ’æŸ¥

**é—®é¢˜ï¼šç›¸æœºè®¾å¤‡è¢«å ç”¨**
```bash
# è§£å†³æ–¹æ³•
lsof /dev/video* 2>/dev/null
kill -9 <PID>
```

**é—®é¢˜ï¼šæ—¶é—´æˆ³éªŒè¯å¤±è´¥**
```bash
# æ£€æŸ¥æ—¥å¿—ä¸­çš„æ—¶é—´æˆ³ç»Ÿè®¡
grep "Timestamp Debug" /tmp/test-log.txt

# å¦‚æœå·®å¼‚ä»ç„¶è¶…è¿‡1.0sï¼Œè€ƒè™‘è¿›ä¸€æ­¥å¢åŠ å®¹å·®
```

**é—®é¢˜ï¼šé‡è¯•å¤±è´¥**
```bash
# æ£€æŸ¥æ˜¯å¦æ­£ç¡®æ£€æµ‹åˆ°é‡è¯•
grep "Retry detected" /tmp/test-log.txt
grep "already processed" /tmp/test-log.txt
```

---

## é™„å½•

### A. ç›¸å…³é…ç½®æ–‡ä»¶

**æ•°æ®å½•åˆ¶é…ç½®**ï¼š
- `operating_platform/teleop_vr/dora_leader_follower_x5.yml`
- `operating_platform/teleop_vr/dora_vr_x5_record.yml`

**æœºå™¨äººé…ç½®**ï¼š
- `operating_platform/robot/robots/configs.py`

**å¯åŠ¨è„šæœ¬**ï¼š
- `scripts/run_so101.sh`

### B. å…³é”®å‡½æ•°

**æ•°æ®ä¿å­˜**ï¼š
- `DoRobotDataset.save_episode()` - ä¸»ä¿å­˜å‡½æ•°
- `DoRobotDataset._save_episode_table()` - ä¿å­˜ parquet è¡¨æ ¼
- `validate_episode_buffer()` - éªŒè¯æ•°æ®å®Œæ•´æ€§
- `check_timestamps_sync()` - éªŒè¯æ—¶é—´æˆ³åŒæ­¥

**å¼‚æ­¥ä¿å­˜**ï¼š
- `AsyncEpisodeSaver.queue_save()` - é˜Ÿåˆ—åŒ–ä¿å­˜ä»»åŠ¡
- `AsyncEpisodeSaver._execute_save()` - æ‰§è¡Œä¿å­˜
- `AsyncEpisodeSaver._handle_save_failure()` - å¤„ç†å¤±è´¥å’Œé‡è¯•

### C. æ•°æ®æµç¨‹

```
å½•åˆ¶å¼€å§‹
  â†“
é‡‡é›†æ•°æ® (add_frame)
  â†“
åˆ›å»º episode_buffer
  â†“
é˜Ÿåˆ—åŒ–ä¿å­˜ (queue_save)
  â†“
æ·±æ‹·è´ buffer (deepcopy)
  â†“
å¼‚æ­¥ä¿å­˜ (save_episode)
  â”œâ”€ éªŒè¯æ•°æ® (validate_episode_buffer)
  â”œâ”€ è½¬æ¢æ•°æ® (pop, stack, fill)
  â”œâ”€ ä¿å­˜è¡¨æ ¼ (_save_episode_table)
  â”œâ”€ ç¼–ç è§†é¢‘ (encode_episode_videos)
  â”œâ”€ éªŒè¯æ—¶é—´æˆ³ (check_timestamps_sync)
  â””â”€ ä¿å­˜å…ƒæ•°æ® (meta.save_episode)
  â†“
ä¿å­˜æˆåŠŸ / å¤±è´¥é‡è¯•
```

### D. å‚è€ƒèµ„æ–™

**ç›¸å…³æ–‡æ¡£**ï¼š
- `operating_platform/teleop_vr/VR_X5_åæ ‡ç³»å¯¹åº”å…³ç³».md`
- `operating_platform/teleop_vr/README-æ•°æ®å½•åˆ¶.md`
- `operating_platform/teleop_vr/README-æœ€ç»ˆä½¿ç”¨æŒ‡å—.md`

**ç›¸å…³ Issue**ï¼š
- æ—¶é—´æˆ³åŒæ­¥é—®é¢˜
- é‡è¯•æœºåˆ¶è®¾è®¡
- æ•°æ®ç±»å‹å¤„ç†

---

## æ€»ç»“

é€šè¿‡ç³»ç»Ÿæ€§çš„è°ƒè¯•å’Œä¿®å¤ï¼Œè§£å†³äº†æ•°æ®ä¿å­˜è¿‡ç¨‹ä¸­çš„æ‰€æœ‰é—®é¢˜ï¼š

âœ… **å·²è§£å†³**ï¼š
1. æ—¶é—´æˆ³åŒæ­¥éªŒè¯ï¼ˆå¢åŠ å®¹å·®åˆ° 1.0sï¼‰
2. é‡è¯•æœºåˆ¶å¤±æ•ˆï¼ˆæ”¹è¿›æ•°æ®æ¨æ–­é€»è¾‘ï¼‰
3. æ•°ç»„ç±»å‹åˆ¤æ–­ï¼ˆå¤„ç†æ ‡é‡å’Œæ•°ç»„ä¸¤ç§æƒ…å†µï¼‰
4. "index" é”®å†²çªï¼ˆæ£€æŸ¥ç±»å‹è€Œä¸ä»…ä»…æ£€æŸ¥å­˜åœ¨ï¼‰
5. å†…éƒ¨æ ‡è®°é”®å†²çªï¼ˆåŠæ—¶æ¸…ç†æ ‡è®°ï¼‰
6. é‡å¤ä¿®æ”¹æ•°æ®ï¼ˆä½¿ç”¨æ ‡è®°è·Ÿè¸ªçŠ¶æ€ï¼‰
7. ç›¸æœºè®¾å¤‡å ç”¨ï¼ˆæ¸…ç†æ®‹ç•™è¿›ç¨‹ï¼‰

ğŸ¯ **å…³é”®ç»éªŒ**ï¼š
- ä½¿ç”¨æ˜¾å¼æ ‡è®°è€Œä¸æ˜¯æ¨æ–­çŠ¶æ€
- ç¡®ä¿æ“ä½œçš„å¹‚ç­‰æ€§
- æ·»åŠ è¯¦ç»†çš„è°ƒè¯•æ—¥å¿—
- è€ƒè™‘é‡è¯•å’Œå¼‚å¸¸åœºæ™¯
- æ£€æŸ¥æ•°æ®ç±»å‹å’Œå½¢çŠ¶

ğŸ“Š **å½“å‰çŠ¶æ€**ï¼š
- æ•°æ®å¯ä»¥æ­£å¸¸ä¿å­˜
- Parquet æ–‡ä»¶åˆ›å»ºæˆåŠŸ
- è§†é¢‘ç¼–ç æ­£å¸¸
- é‡è¯•æœºåˆ¶å·¥ä½œæ­£å¸¸

---

*æ–‡æ¡£ç»´æŠ¤è€…ï¼šClaude Sonnet 4.5*
*æœ€åæ›´æ–°ï¼š2026-02-04*
